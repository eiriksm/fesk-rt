<!doctype html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>FESK Real-Time Decoder</title>
<style>
  *, *::before, *::after { box-sizing: border-box; }
  body {
    margin: 0;
    padding: clamp(16px, 4vw, 32px);
    font-family: system-ui, sans-serif;
    line-height: 1.5;
    background: #f7f7f7;
  }
  .app {
    max-width: 720px;
    margin: 0 auto;
    background: #fff;
    padding: clamp(16px, 4vw, 32px);
    border-radius: 16px;
    box-shadow: 0 4px 16px rgba(0,0,0,0.06);
  }
  h1 {
    margin-top: 0;
    margin-bottom: 1rem;
    font-size: clamp(1.5rem, 2.5vw, 2rem);
  }
  button {
    padding: .6rem 1.1rem;
    border: 1px solid #ccc;
    border-radius: 10px;
    background: #fff;
    cursor: pointer;
    font: inherit;
    transition: background-color .2s ease, border-color .2s ease, box-shadow .2s ease;
  }
  button:hover:not(:disabled),
  button:focus-visible {
    border-color: #888;
    background: #f0f0f0;
    box-shadow: 0 0 0 3px rgba(0,0,0,0.05);
  }
  button:disabled {
    cursor: not-allowed;
    opacity: .6;
  }
  .row {
    margin: 1rem 0;
  }
  .controls {
    display: flex;
    flex-wrap: wrap;
    gap: .75rem;
  }
  .controls button {
    flex: 1 1 220px;
    min-width: 140px;
  }
  .muted {
    color: #666;
    font-size: .875rem;
  }
  .info-row {
    display: flex;
    flex-wrap: wrap;
    gap: .75rem 1.5rem;
  }
  .info-item {
    display: flex;
    gap: .35rem;
    align-items: baseline;
    font-size: 1rem;
  }
  #out {
    white-space: pre-wrap;
    font: 14px/1.5 ui-monospace, SFMono-Regular, Menlo, monospace;
    border: 1px solid #ddd;
    border-radius: 12px;
    padding: 12px;
    min-height: 6rem;
    background: #fafafa;
    overflow-x: auto;
  }
  @media (max-width: 480px) {
    .info-item strong { white-space: nowrap; }
  }
</style>

<div class="app">
  <h1>FESK Real-Time Decoder</h1>
  <div class="row controls">
    <button id="startBtn">Start üéôÔ∏è</button>
    <button id="stopBtn" disabled>Stop üö´</button>
    <button id="sampleBtn">Play Sample üîä</button>
  </div>
  <div class="row info-row">
    <div class="info-item"><strong>Status:</strong> <span id="status">idle</span></div>
    <div class="info-item"><strong>SR:</strong> <span id="sr">‚Äî</span></div>
    <div class="info-item"><strong>Bank A:</strong> <span id="freq0">‚Äî</span></div>
    <div class="info-item"><strong>Bank B:</strong> <span id="freq1">‚Äî</span></div>
  </div>
  <div class="row"><strong>Decoded output:</strong></div>
  <div id="out"></div>
</div>

<script type="module">
// =================== CONFIG ===================
const TONE_MS = 62.5;    // 4 ticks @ 64 Hz
const REST_MS = 62.5;    // 4 ticks @ 64 Hz (set to 15.625 for 1-tick gap, or 0 for max speed)
const ENERGY_FLOOR = 1e-7; // raise a bit if your room is noisy
const SAMPLE_WAV_URL = 'sample.wav';

// Two frequency banks (Hz) ‚Äî adjust as needed.
// Bank A matches your spec (index 0..3): 0‚ÜíF7, 1‚ÜíA7, 2‚ÜíD8, 3‚ÜíG6
const FREQS_SETS = [
  [2793.83, 3520.00, 4698.63, 1567.98], // Bank A (spec)
  [2700.00, 3400.00, 4600.00, 1600.00], // Bank B (alt/tolerant)
];
// Framing marker
const FRAME_MARK = "333";

// =================== SYMBOL TABLE (prefix-free) ===================
// Letters (2-symbol short)
const MAP = new Map([
  ["00","a"],["01","b"],["02","c"],["03","d"],
  ["10","e"],["11","f"],["12","g"],["13","h"],
  ["20","i"],["21","j"],["22","k"],["23","l"],

  // m..p
  ["300","m"],["301","n"],["302","o"],["303","p"],

  // q split to 3100, r s t unchanged
  ["3100","q"],["311","r"],["312","s"],["313","t"],

  // u split to 3200, v w x unchanged
  ["3200","u"],["321","v"],["322","w"],["323","x"],

  // y split to 3300
  ["3300","y"],

  // z and punctuation
  ["3310","z"],["3311"," "],["3312",","],["3313",":"],

  // digits
  ["332","0"],
  ["3301","1"],["3302","2"],["3303","3"],
  ["3201","4"],["3202","5"],["3203","6"],
  ["3101","7"],["3102","8"],["3103","9"],
]);

// Build trie for variable-length decoding
function buildTrie(map) {
  const root = {};
  for (const [code, ch] of map.entries()) {
    let n = root;
    for (const d of code) { n[d] = n[d] || {}; n = n[d]; }
    n.$ = ch;
  }
  return root;
}
const TRIE = buildTrie(MAP);

// CRC-5 over payload symbols (trits 0..3): additive mod 32, LE base-4 to 3 trits
function crcSymbols(trits) {
  let crc = 0;
  for (const s of trits) crc = (crc + s) & 31;
  const d0 = crc & 3, d1 = (crc >> 2) & 3, d2 = (crc >> 4) & 3;
  return [d0, d1, d2];
}

// Decode payload trits via trie
function decodePayloadTrits(trits) {
  const out = [];
  let node = TRIE;
  for (let i = 0; i < trits.length; i++) {
    const d = String(trits[i]);
    if (!node[d]) return { ok:false, text:null, err:`bad code at index ${i}` };
    node = node[d];
    if (node.$) { out.push(node.$); node = TRIE; }
  }
  if (node !== TRIE) return { ok:false, text:null, err:"truncated code at end" };
  return { ok:true, text: out.join("") };
}

// =================== UI helpers ===================
const statusEl = document.getElementById('status');
const outEl = document.getElementById('out');
const srEl = document.getElementById('sr');
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const sampleBtn = document.getElementById('sampleBtn');
const freqEls = FREQS_SETS.map((_, i) => document.getElementById(`freq${i}`));

function setStatus(s){ statusEl.textContent = s; }
function print(s){ outEl.textContent += s; }
function formatFreq(f){
  const txt = f.toFixed(1);
  return (txt.endsWith('.0') ? txt.slice(0, -2) : txt) + ' Hz';
}
function resetFreqDisplays(){ for (const el of freqEls) if (el) el.textContent = '‚Äî'; }

resetFreqDisplays();

// =================== Dual decoder state ===================
function mkDec() { return {state:'idle', recent:[], frameTrits:[], scores:[]}; }
const DEC = [ mkDec(), mkDec() ];
function resetDec(d){ d.state='idle'; d.recent.length=0; d.frameTrits.length=0; d.scores.length=0; }
function resetAllDecoders(){ for (const d of DEC) resetDec(d); }

async function cleanup(nextStatus){
  if (bufferSrc) {
    bufferSrc.onended = null;
    try { bufferSrc.stop(); } catch (_) {}
    try { bufferSrc.disconnect(); } catch (_) {}
    bufferSrc = null;
  }
  if (workletNode) {
    workletNode.port.onmessage = null;
    try { workletNode.disconnect(); } catch (_) {}
    workletNode = null;
  }
  if (mediaSrc) {
    try { mediaSrc.disconnect(); } catch (_) {}
    mediaSrc = null;
  }
  if (mediaStream) {
    for (const track of mediaStream.getTracks()) track.stop();
    mediaStream = null;
  }
  if (audioCtx) {
    try { await audioCtx.close(); } catch (_) {}
    audioCtx = null;
  }
  srEl.textContent = '‚Äî';
  resetAllDecoders();
  resetFreqDisplays();
  suppressReadyStatus = false;
  if (typeof nextStatus === 'string') setStatus(nextStatus);
}

async function initProcessingChain(){
  resetAllDecoders();
  resetFreqDisplays();
  setStatus('initializing audio‚Ä¶');
  audioCtx = new (window.AudioContext || window.webkitAudioContext)({latencyHint:'interactive'});
  srEl.textContent = audioCtx.sampleRate.toFixed(0) + ' Hz';
  const blob = new Blob([workletSource], {type:'application/javascript'});
  const url = URL.createObjectURL(blob);
  try {
    await audioCtx.audioWorklet.addModule(url);
  } finally {
    URL.revokeObjectURL(url);
  }
  workletNode = new AudioWorkletNode(audioCtx, 'mb-fesk', {numberOfInputs:1, numberOfOutputs:0});
  workletNode.port.onmessage = (e)=>{
    const m = e.data;
    if (m.t==='ready') {
      if (!suppressReadyStatus) setStatus('ready');
    }
    else if (m.t==='candidates') handleCandidates(m.results);
  };
  const toneSamples = Math.max(32, Math.round(audioCtx.sampleRate * (TONE_MS/1000)));
  const restSamples = Math.max(0, Math.round(audioCtx.sampleRate * (REST_MS/1000)));
  workletNode.port.postMessage({freqSets: FREQS_SETS, toneSamples, restSamples});
  return workletNode;
}

function feedOne(dec, symIdx, score) {
  dec.recent.push(symIdx);
  if (dec.recent.length > 3) dec.recent.shift();

  if (dec.state === 'idle') {
    if (dec.recent.length === 3 && dec.recent[0]===3 && dec.recent[1]===3 && dec.recent[2]===3) {
      dec.state = 'in';
      dec.frameTrits = [];
      dec.scores = [];
      dec.recent = [];
    }
    return null;
  }

  if (dec.state === 'in') {
    if (dec.recent.length === 3 && dec.recent[0]===3 && dec.recent[1]===3 && dec.recent[2]===3) {
      // finalize frame
      if (dec.frameTrits.length < 3) { const r={ok:false, okCRC:false, why:'short'}; resetDec(dec); return r; }
      const recvCRC = dec.frameTrits.slice(-3);
      const payload = dec.frameTrits.slice(0, -3);
      const wantCRC = crcSymbols(payload);
      const okCRC = (recvCRC[0]===wantCRC[0] && recvCRC[1]===wantCRC[1] && recvCRC[2]===wantCRC[2]);
      let ok=false, text=null;
      if (okCRC) {
        const res = decodePayloadTrits(payload);
        ok = res.ok; text = res.text;
      }
      const avgScore = dec.scores.length ? dec.scores.reduce((a,b)=>a+b,0)/dec.scores.length : 0;
      const result = {ok, okCRC, text, avgScore};
      resetDec(dec);
      return result;
    } else {
      dec.frameTrits.push(symIdx);
      dec.scores.push(score ?? 0);
    }
  }
  return null;
}

// =================== Worklet (multi-bank) ===================
const workletSource = `
class MultiBankFESK extends AudioWorkletProcessor {
  constructor(){
    super();
    this.ready=false; this.buf=[];
    this.Nsym=0; this.Ngap=0;
    this.banks=[]; // [{coeffs: Float32Array(4)}]
    this.energyFloor = ${ENERGY_FLOOR};
    this.port.onmessage = e=>{
      const {freqSets, toneSamples, restSamples} = e.data;
      this.Nsym = Math.max(32, toneSamples|0);
      this.Ngap = Math.max(0,  restSamples|0);
      this.banks = freqSets.map(freqs=>{
        const coeffs = new Float32Array(4);
        for (let i=0;i<4;i++){
          const k = Math.round(this.Nsym * freqs[i] / sampleRate);
          const omega = 2*Math.PI*k / this.Nsym;
          coeffs[i] = 2*Math.cos(omega);
        }
        return {coeffs};
      });
      this.ready=true; this.port.postMessage({t:'ready', sr: sampleRate});
    };
  }
  _goertzel(block, coeffs){
    const N = block.length; const out = new Float32Array(4);
    let s0,s1,s2;
    for (let i=0;i<4;i++){
      const c=coeffs[i]; s0=0; s1=0; s2=0;
      for (let n=0;n<N;n++){ s0 = block[n] + c*s1 - s2; s2=s1; s1=s0; }
      out[i] = s1*s1 + s2*s2 - c*s1*s2;
    }
    return out;
  }
  process(inputs){
    if (!this.ready) return true;
    const x = inputs[0]?.[0]; if (!x) return true;
    for (let i=0;i<x.length;i++) this.buf.push(x[i]);
    while (this.buf.length >= this.Nsym){
      const block = this.buf.splice(0, this.Nsym);
      // small edge ramps (‚âà5ms)
      const w = Math.min(Math.floor(0.005*sampleRate), block.length>>2);
      if (w>0){
        for (let i=0;i<w;i++){ const r=0.5-0.5*Math.cos(Math.PI*i/(w-1)); block[i]*=r; block[block.length-1-i]*=r; }
      }
      const results = [];
      for (let b=0; b<this.banks.length; b++){
        const P = this._goertzel(block, this.banks[b].coeffs);
        const energy = P[0]+P[1]+P[2]+P[3];
        if (energy <= this.energyFloor){ results.push({bank:b, active:false}); continue; }
        // winner + margin score
        let iMax=0, vMax=P[0], i2=1, v2=P[1];
        for (let i=1;i<4;i++){
          if (P[i]>vMax){ i2=iMax; v2=vMax; iMax=i; vMax=P[i]; }
          else if (P[i]>v2){ i2=i; v2=P[i]; }
        }
        const score = (vMax - v2) / Math.max(1e-12, energy);
        results.push({bank:b, active:true, idx:iMax, score});
      }
      this.port.postMessage({t:'candidates', results});
      if (this.Ngap>0 && this.buf.length>=this.Ngap) this.buf.splice(0, this.Ngap);
    }
    return true;
  }
}
registerProcessor('mb-fesk', MultiBankFESK);
`;

// =================== Boot & wire-up ===================
let audioCtx = null;
let mediaStream = null;
let mediaSrc = null;
let workletNode = null;
let bufferSrc = null;
let suppressReadyStatus = false;

startBtn.addEventListener('click', async () => {
  startBtn.disabled = true;
  stopBtn.disabled = true;
  sampleBtn.disabled = true;
  try {
    await cleanup(null);
    await initProcessingChain();
    setStatus('requesting microphone‚Ä¶');
    mediaStream = await navigator.mediaDevices.getUserMedia({
      audio: { echoCancellation:false, noiseSuppression:false, autoGainControl:false, channelCount:1 }
    });
    mediaSrc = audioCtx.createMediaStreamSource(mediaStream);
    mediaSrc.connect(workletNode);
    setStatus('listening‚Ä¶ wait for 333 start marker');
    stopBtn.disabled = false;
  } catch (err) {
    setStatus('error: ' + (err && err.message || err));
    await cleanup(null);
    startBtn.disabled = false;
    sampleBtn.disabled = false;
    stopBtn.disabled = true;
  }
});

stopBtn.addEventListener('click', async () => {
  stopBtn.disabled = true;
  try {
    await cleanup('stopped');
  } finally {
    startBtn.disabled = false;
    sampleBtn.disabled = false;
  }
});

sampleBtn.addEventListener('click', async () => {
  startBtn.disabled = true;
  sampleBtn.disabled = true;
  stopBtn.disabled = true;
  try {
    await cleanup(null);
    suppressReadyStatus = true;
    await initProcessingChain();
    setStatus('loading WAV‚Ä¶');
    const response = await fetch(SAMPLE_WAV_URL);
    if (!response.ok) throw new Error(`fetch failed (${response.status})`);
    const arrayBuffer = await response.arrayBuffer();
    const audioBuffer = await new Promise((resolve, reject) => {
      audioCtx.decodeAudioData(arrayBuffer, resolve, reject);
    });
    if (!audioBuffer || audioBuffer.numberOfChannels === 0) {
      throw new Error('empty or unsupported WAV payload');
    }
    let playbackBuffer = audioBuffer;
    if (audioBuffer.numberOfChannels > 1) {
      const length = audioBuffer.length;
      const mono = audioCtx.createBuffer(1, length, audioBuffer.sampleRate);
      const out = mono.getChannelData(0);
      for (let ch = 0; ch < audioBuffer.numberOfChannels; ch++) {
        const data = audioBuffer.getChannelData(ch);
        for (let i = 0; i < length; i++) out[i] += data[i];
      }
      for (let i = 0; i < out.length; i++) out[i] /= audioBuffer.numberOfChannels;
      playbackBuffer = mono;
    }
    bufferSrc = audioCtx.createBufferSource();
    bufferSrc.buffer = playbackBuffer;
    bufferSrc.connect(workletNode);
    bufferSrc.start();
    bufferSrc.onended = async () => {
      const finished = bufferSrc;
      if (finished) {
        finished.onended = null;
        try { finished.disconnect(); } catch (_) {}
      }
      bufferSrc = null;
      stopBtn.disabled = true;
      await cleanup('sample finished');
      startBtn.disabled = false;
      sampleBtn.disabled = false;
    };
    setStatus('playing sample‚Ä¶');
    stopBtn.disabled = false;
  } catch (err) {
    setStatus('error: ' + (err && err.message || err));
    await cleanup(null);
    startBtn.disabled = false;
    sampleBtn.disabled = false;
    stopBtn.disabled = true;
  }
});

// Handle candidates from both banks
function handleCandidates(results){
  const activeBanks = new Array(freqEls.length).fill(false);
  // For each active bank candidate, feed its decoder
  for (const r of results) {
    if (!r.active) continue;
    if (freqEls[r.bank]) {
      freqEls[r.bank].textContent = formatFreq(FREQS_SETS[r.bank][r.idx]);
      activeBanks[r.bank] = true;
    }
    const out = feedOne(DEC[r.bank], r.idx, r.score);
    if (out) {
      // Print as soon as a bank returns a CRC-valid decoded frame
      if (out.ok && out.okCRC && out.text) {
        print(out.text);
        setStatus(`frame OK (bank ${r.bank})`);
      }
    }
  }
  for (let i = 0; i < activeBanks.length; i++) {
    if (!activeBanks[i] && freqEls[i]) freqEls[i].textContent = '‚Äî';
  }
}
</script>
